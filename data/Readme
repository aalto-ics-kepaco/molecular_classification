



< Download Data >
-. Take a look at http://dtp.cancer.gov/index.html to get an overview of the drug screen project.
-. Either process the data with your own scripts or follow the scripts and instruction.
-. The goad here is to better understand the structure of the data source and to validate the processed data.
        -. Go to http://www.ncbi.nlm.nih.gov/pcassay and search with keywords 'DTP/NCI'.
        -. Download the list of cellline AIDs that correspond to the celllines in DTP/NCI project and save AIDs to the file:../DTPNCI2015/otherfiles/pcassay.
        -. For each cell line, download its data file from ftp://ftp.ncbi.nlm.nih.gov/pubchem/Bioassay/CSV/Data/0000001_0001000.zip according to its AID. This will be a zip file covers all cell line data files in DTP/NCI project. 
        -. Each cell line data file will contain a list of compounds with their test activities in this cell line. Take a look at cell line AID-109 (https://pubchem.ncbi.nlm.nih.gov/assay/assay.cgi?aid=109) to have a better understanding of the data.
        -. Parse the cellline data files to extract the data we need which is a m by k matrix of activity scores of m molecules in k celllines.
        -. Save the processed data to the file:./activity_complete.


< Process Data >
-. So far, we have around 40,000 molecules with their activities in about 70 cell lines. There exist two problems with this data matrix in the file:./activity.txt which we should tackle.
-. The first problem is that we still need structural information for molecules, based on which we can measure the similaries with e.g. kernel methods.
        -. The structural information of molecules are in the folder:./molecular_structures, where there are two types of structural information for molecules, namely, SDF files and SMI strings. 
        -. Note that we may not have a complete set of structures. Therefore, we need to filter the activity matrix against the set of molecular structures available in the folder.
-. The second problem is that the activity score matrix in the file:activity_complete is not complete. In other words, there area many entries with missing value. This is problemetic during learning in the later phase.
        -. To tackle the second problem, we will organize the score matrix such that the complete information will appear in the upper left block of the whole matrix.
        -. We are given a set of 60 cancer cell lines in the file:otherfiles/id2aid2names. These cell lines are the ones with additional information e.g. in cell miner (http://discover.nci.nih.gov/cellminer/home.do).
        -. First, we organize the score matrix such that the first 60 columns will correspond to these 60 cell lines, and the rest will follow. In particular, we have column structure as 60 + 13. 
        -. Then we organize the rows of the score matrix such that the first ~4000 rows will correspond to the molecules that have complete data in these 60 cell lines. The rest will follow.
-. We notice that the activity score is computed according -10*log(GI50). We still need binary value as the activity outcome for classification task. According to NCBI, a molecule is 'active' if the activity score is over( >=) 60 and 'inactive' otherwise.


< Kernel Computation >
-. To measure the similary between pair of molecules as well as to enable kernel based learning algorithms, we need to compute a m by m kernel matrix.
-. Kernel functions that we will be using in this project include Fingerprint-Tanimoto kernel and many graph kernels.
-. Figureprint-Tanimoto kernels:
        -. The first step is to generate for each molecule a fingerprint vector.
                -. The python script compute_fingerprint_parallel.py will compute different type of molecular fingerprints in parallel in an interactive cluster (e.g. UKKO cluster of CS Department in University of Helsinki).
                -. There are serveral type of molecular fingerprints that can be generated by open source softwares. Here we only consider fingerprint of type fp2, fp3, and fp4 generated by Openbabel (http://openbabel.org/wiki/Tutorial:Fingerprints).
                -. The fp2 fingerprints we use are linear fragments upto 7 atoms. We have studied fp2 fingerprint in the previous work. Fp3 and fp4 fingerprints can also be studied based on the same principle.
                -. Read more about fingerprint in Openbabel user manual. 
                -. Given a molecular structure in SDF file, this fingerprint can be generated by OpenBabel (http://openbabel.org/wiki/Main_Page), see the link for more information. 
                -. We need to generate the fingerprints of around 40,000 molecules. It is important to parallelize the computation in a computer cluster e.g. Triton in Aalto, Ukko in University of Helsinki.
                -. The scripts for fingerprint computation and parallelization can be found from the project folder.
        -. The next step is to compute the Tanimoto kernel based on the fingerprints. 
                -. The perl script compute_tanimoto_kernel.pl will compute the elements in the kernel matrix. The perl script will make the pairwise comparison faster.
                -. Tanimoto kernel function is defined on two binary bit vectors. See https://en.wikipedia.org/wiki/Jaccard_index for more information.
                -. As the boolean operations (and, or) on two long bit vectors are not cheap. Perl or Bash programmings are recommended which allow fast processing on strings. In particular, Perl scripts can be found from project folder.
                -. Notice that we do not need the kernel for all 40,000 molecule. We only need the kernel for the roughly 4,000 molecules which have complete activity over 60 cancer cell lines.
                -. In the end, we only compute the kernel matrix for 5,000 molecules which will cover all molecules with complete activity over 60 cancer cell lines.
-. Graph kernels:
        -. We will use open source package (http://www.bsse.ethz.ch/mlcb/research/machine-learning/graph-kernels.html) to compute graph kernels.
        -. The first step is to convert each molecule into a adjacency matrix.
                -. The python script compute_fingerprint_parallel.py will compute the adjacency of each molecule, and save the result as a matlab data file.
                -. The script will run in parallel in a interactive cluster.
                -. the script will take in a sdf file of a molecule, and output a adjacency matrix.
        -. With all molecules in adjacency matrices, we can compute many kinds of graph kenrels. 


< Result files >
-. List of files generated from preprocessing:
        ./DTPNCI2015/results/ncicancer_activities       m by k matrix of activity scores
        ./DTPNCI2015/results/ncicancer_aids             1 by k matrix of cell line AIDs
        ./DTPNCI2015/results/ncicancer_features         m by d matrix of figureprint features for each molecules
        ./DTPNCI2015/results/ncicancer_labels           m by 1 matrix of molecule NSC IDs
        ./DTPNCI2015/results/ncicancer_targets          m by k matrix of activity outcomes
        ./DTPNCI2015/results/ncicancer_kernel           m by m kernel matrix, m=5000 
-. The kernel file is not in the GitHub due to the size limit.
-. These are inputs to the kernel based learning algorithms.


< Scripts >
-. List of preprocessing scripts, in the order of preprocessing:

        # Update activity files of NCI cancer cell lines
        update_ncicancer_actfiles.py

        # Select molecules with arrange the activity score matrix
        update_ncicancer_selections.py
        update_ncicancer_selections.r

        # Compute for each molecule a fingerprint vector, note that you need to modify the code a little in order to computer fp3 and fp3 features.
        compute_fingerprint_parallel.py

        # Based on the computed fingerprints, construct Fingerprint-Tanimoto kernel, note that you need to modify the code a little in order to compute the kernel for fp3 and fp4 features.
        compute_fp_feature_matrix.py
        compute_tanimoto_kernel.pl
        complete_tanimoto_kernel_matrix.r

